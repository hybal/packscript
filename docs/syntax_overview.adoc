= Syntax Overview
:hardbreaks:

This is an overview of the common syntax and functions that you can use in PackScript

== Variables

there are two kinds of variables, local and global. Local variables are declared with the `let` keyword and global variables with `set`.
[source, packscript]
----
let local = 1
set global = 2
----

there is also a difference in how you refer to these variables. Local variables are used normally without any differences, but to use a global variable you have to prefix it with `g:` (*This will likely change!!*)
[source, packscript]
----
let local = 1

print local #nothing different

set global = "xyz"

print g:global #prefixed with g:
----

== Functions

Functions are basically everything in PackScript, since it is a functional language they are also values that can be passed around.

to call a function in PackScript you just write the function name followed by the parameters it takes.
[source, packscript]
----
print "Hello, World"
----

Note that there are no parenthesis, in PackScript parenthesis are optional and for the most part you do not need to include them.

For those coming from other functional languages (mainly Haskell), the syntax for parameters is a little bit different than there. Mainly that commas are required to separate the different parameters.
[source, packscript]
----
add 1, 2 #adds two numbers; Returns: 3
----

to create a function is similar to how you declare a variable, just with the addition of parameters before the equal sign (=)
[source, packscript]
----
let add (a,b) = a + b
----

note that to have a function that does not take any parameters, you still have to include the parenthesis, there *is* a difference between functions and normal variables.
[source, packscript]
----
let num () = 123456 #this is a function, you have to call it with num() to get the value
let num2 = 123456 #this is just a variable and cannot be called (unless the value is a function as well)
----

If you need to do more than just one expression you can use a _block_, in which case you can use the `return` keyword to return a value.
[source, packscript]
----
let print_me (str) = {
    print "I say hi"
    print "I also say "..str
    return true
}
----

Blocks are essentially just lambdas or anonymous functions so you can use them with normal variables as well
[source, packscript]
----
let normal_var = {
    print "I am a block"
}

normal_var() #prints: I am a block
----

if you need to pass parameters into a block you can declare them before the block (you can also do this with just an expression).
[source, packscript]
----
let block_with_params = (a,b) -> {a+b}
----

=== Currying

Functions in PackScript can also be _curried_ which means you can pass only a portion of the required parameters into a function and it will just return a *new* function that takes the rest of the parameters. Only after all of the parameters have been passed will the function be executed.
[source, packscript]
----
let add (a,b) = a + b

let partial_add = add 35 #returns a new function that takes b

print partial_add 89 #prints 124
----

== Shell Functions

[WARNING]
You should only use shell functions when required, since shell commands are not cross-platform you cannot guarantee that it will work everywhere. Instead use the standard library functions as much as possible.

You can easily run any arbitrary shell function by just starting a line with a bang (!)
[source, packscript]
----
!echo "Hello, World!"
----

However, the process is not privileged by default (so on linux you can't use `sudo`). However you can ask for those permissions by adding another bang (!!). This will pause the script and ask the user for permission to elevate privileges. (this will likely change)
[source, packscript]
!!sudo apt update

[NOTE]
every bang-command uses the same process that is created on startup, if you need to create a new one see `exec`

Shell Functions are treated as the same thing as normal functions, so they can be used as values.
The output of a shell function is returned as a tuple of `(string, int)` where the first element is the output of the command (either stdout or stderr), and the second is the return code.  


